package main

import "fmt"

// pc[i] is the population count of i.
var pc [256]byte

// 为什么数组长度是256（0~255）？
// 1. 8位二进制数的特性：
// 		> 1个字节（byte）= 8位二进制, 8位二进制能表示的最大数是 11111111 = 255（2⁸-1）
// 2. 空间与时间的平衡：
// 		> 如果使用更大的块（如16位），表大小会膨胀到65536（2¹⁶），占用256倍内存
// 		> 而使用8位块，每次处理64位数需要查表8次，在时间和空间之间找到了完美平衡
// 3. 硬件友好性：
// 		> CPU处理单字节的查表操作极为高效
// 		> 现代CPU缓存能轻松容纳256字节的小表，避免缓存未命中

// 任何一个数 i 的二进制形式可以看作：i = (i >> 1) << 1 + (i & 1)
// pc[i] = pc[i >> 1] + (i & 1)

//  为什么 i >> 1 等价于 i/2
// 101 (5) → 10 (2)   // 5/2 = 2.5 → 向下取整为2
// 110 (6) → 11 (3)   // 6/2 = 3
// 二进制数的每一位代表 2 的幂次，右移一位相当于所有位的权值减半：
// 结论：对无符号整数，右移一位等价于整数除法（丢弃小数部分）。

// i&1 直接判断当前数是否为奇数（最低位是否为 1）
func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1) // 当 i=3 或 5 时，pc[i/2] 如何取值？Go 语言中整数除法会直接舍弃小数部分（向下取整) ，
	}
}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
	return int(pc[byte(x>>(0*8))] +
		pc[byte(x>>(1*8))] +
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}

// 分字节处理：
// 将64位数 x 拆分为8个8位（1字节）的部分。
// 通过右移操作 x >> (n*8) 获取从低到高的每个字节（n从0到7）。
// 用 byte() 截取右移后的最低8位，得到每个字节的值。

func main() {
	fmt.Println(PopCount(184467440737095))
}
